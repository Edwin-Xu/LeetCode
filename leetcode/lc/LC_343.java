package leetcode.lc;

/**
 * Created by Edwin Xu on 7/30/2020 6:14 PM
 * 343. 整数拆分
 * 给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。
 * <p>
 * 示例 1:
 * <p>
 * 输入: 2
 * 输出: 1
 * 解释: 2 = 1 + 1, 1 × 1 = 1。
 * 示例 2:
 * <p>
 * 输入: 10
 * 输出: 36
 * 解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。
 * 说明: 你可以假设 n 不小于 2 且不大于 58。
 * <p>
 * <p>
 * <p>
 * 分析
 * 划分份数：从2-N/2
 * 即每份多个相同的数，然后剩下的没人分一份
 */
public class LC_343 {
    public int integerBreak(int n) {
        if (n == 1) return 1;
        double max = -1;
        for (int i = 2; i <= n ; i++) {
            //分为i份
            int x = n / i;//每份x
            int y = n % i;//剩下y个
//            System.out.println(i+" "+x+" "+y);
            double mul = Math.pow(x + 1, y) * Math.pow(x, i - y);
            if (max < mul) max = mul;
        }
        return (int) max;
    }

    public static void main(String[] args) {
        LC_343 l = new LC_343();
        System.out.println(l.integerBreak(2));
        System.out.println(l.integerBreak(10));
    }
}


/*
* 数学解法：
* 方法三：数学
方法二中利用了数学知识降低时间复杂度。正整数 44 可以拆分成 2+22+2，乘积不变（4=2 \times 24=2×2）。对于大于 44 的正整数，总是存在一种拆分的方案，使得拆分成的两个正整数的乘积大于拆分前的正整数（例如，5=2+35=2+3，2 \times 3=6>52×3=6>5）。那么，能否利用数学知识在方法二的基础上进一步降低时间复杂度，找到最优的拆分方案呢？

下面给出两种直接得出最优拆分方案的证明方法。

函数极值证明法

显然，如果将给定的正整数拆分成尽可能多的某个特定的正整数，则这些正整数的乘积最大。

定义函数 f(x)f(x) 表示将给定的正整数 nn 拆分成尽可能多的正数 xx 的情况下的最大乘积，则可以将 nn 分成 \frac{n}{x}
x
n
​
  项，此时 f(x)=x^{\frac{n}{x}}f(x)=x
x
n
​

 ，目标是求 f(x)f(x) 的最大值，即

\mathop{\max}\limits_{x}(f(x))
x
max
​
 (f(x))

可以将 f(x)f(x) 写成如下形式：

f(x)=x^{\frac{n}{x}}=e^{\frac{n \ln x}{x}}
f(x)=x
x
n
​

 =e
x
nlnx
​



令 g(t)=e^tg(t)=e
t
 ，h(x)=\frac{\ln x}{x}h(x)=
x
lnx
​
 ，则有 f(x)=g(n \cdot h(x))f(x)=g(n⋅h(x))。由于 g(t)g(t) 是单调递增的，n>0n>0，因此 h(x)h(x) 与 f(x)f(x) 的单调性相同。

计算 h(x)h(x) 的驻点，即 h'(x)=\frac{1- \ln x}{x^2}=0h
′
 (x)=
x
2

1−lnx
​
 =0 的点，得到驻点为 x=ex=e。

由于当 0<x<e0<x<e 时 h'(x)>0h
′
 (x)>0，当 x>ex>e 时 h'(x)<0h
′
 (x)<0，因此 x=ex=e 是 h(x)h(x) 的极大值点，也是 f(x)f(x) 的极大值点。由于函数 f(x)f(x) 的定义域连续，因此极大值点唯一，也是最大值点。

因此，当 x=ex=e 时，f(x)f(x) 取到最大值，\max f(x)=f(e)=e^{\frac{n}{e}}maxf(x)=f(e)=e
e
n
​

 。

由于 ee 不是整数，因此使用与 ee 最接近的整数作为 xx 的值，xx 可以是 22 或 33，此时需要比较 f(2)f(2) 与 f(3)f(3) 的大小，可以通过计算 \frac{f(3)}{f(2)}
f(2)
f(3)
​
  进行比较。

\frac{f(3)}{f(2)}=\frac{e^{n \cdot h(3)}}{e^{n \cdot h(2)}}=e^{n \cdot h(3)-n \cdot h(2)}=e^{n \cdot (\frac{\ln 3}{3} - \frac{\ln 2}{2})}=e^{\frac{n}{6} \cdot (2 \ln 3 - 3 \ln 2)}=e^{\frac{n}{6} \cdot (\ln 9 - \ln 8)}
f(2)
f(3)
​
 =
e
n⋅h(2)

e
n⋅h(3)

​
 =e
n⋅h(3)−n⋅h(2)
 =e
n⋅(
3
ln3
​
 −
2
ln2
​
 )
 =e
6
n
​
 ⋅(2ln3−3ln2)
 =e
6
n
​
 ⋅(ln9−ln8)


由于 \ln 9 > \ln 8ln9>ln8，因此 \frac{f(3)}{f(2)}>1
f(2)
f(3)
​
 >1，即 f(3)>f(2)f(3)>f(2)。当 x=3x=3 时，可以得到最大乘积。因此，应该将给定的正整数拆分成尽可能多的 33。

根据 nn 除以 33 的余数进行分类讨论：

如果余数为 00，即 n=3m(m \ge 2)n=3m(m≥2)，则将 nn 拆分成 mm 个 33；

如果余数为 11，即 n=3m+1(m \ge 1)n=3m+1(m≥1)，由于 2 \times 2 > 3 \times 12×2>3×1，因此将 nn 拆分成 m-1m−1 个 33 和 22 个 22；

如果余数为 22，即 n=3m+2(m \ge 1)n=3m+2(m≥1)，则将 nn 拆分成 mm 个 33 和 11 个 22。

上述拆分的适用条件是 n \ge 4n≥4。如果 n \le 3n≤3，则上述拆分不适用，需要单独处理。

如果 n=2n=2，则唯一的拆分方案是 2=1+12=1+1，最大乘积是 1 \times 1=11×1=1；

如果 n=3n=3，则拆分方案有 3=1+2=1+1+13=1+2=1+1+1，最大乘积对应方案 3=1+23=1+2，最大乘积是 1 \times 2=21×2=2。

这两种情形可以合并为：当 n \le 3n≤3 时，最大乘积是 n-1n−1。

归纳证明法

第一步：证明最优的拆分方案中不会出现大于 44 的整数。

假设出现了大于 44 的整数 xx，由于 2(x-2) > x2(x−2)>x 在 x > 4x>4 时恒成立，将 xx 拆分成 22 和 x-2x−2 可以增大乘积。因此最优的拆分方案中不会出现大于 44 的整数。

第二步：证明最优的拆分方案中可以不出现整数 44。

如果出现了整数 44，我们可以用 2 \times 22×2 代替之，乘积不变。

此时，我们可以知道，最优的拆分方案中只会出现 11，22 和 33。

第三步：证明当 n \geq 5n≥5 时，最优的拆分方案中不会出现整数 11。

当 n \geq 5n≥5 时，如果出现了整数 11，那么拆分中剩余的数的和为 n-1 \geq 4n−1≥4，对应这至少两个整数。我们将其中任意一个整数 xx 加上 11，乘积就会增大。因此最优的拆分方案中不会出现整数 11。

此时，我们可以知道，当 n \geq 5n≥5 时，最优的拆分方案中只会出现 22 和 33。

第四步：证明当 n \geq 5n≥5 时，最优的拆分方案中 22 的个数不会超过 33 个。

如果出现了超过 33 个 22，那么将它们转换成 22 个 33，可以增大乘积，即3 \times 3 > 2 \times 2 \times 23×3>2×2×2。

此时，n \geq 5n≥5 的最优拆分方案就唯一了。这是因为当最优的拆分方案中 22 的个数分别为 00，11，22 个时，就对应着 nn 除以 33 的余数分别为 00，22，11 的情况。因此我们可以得到和「函数极值证明法」相同的分类讨论结果。

当 n = 4n=4 时，4 = 2 \times 24=2×2 的最优拆分方案也可以放入分类讨论结果；当 2 \leq n \leq 32≤n≤3 时，只有唯一的拆分方案 1 \times (n - 1)1×(n−1)。

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/integer-break/solution/zheng-shu-chai-fen-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

*
* */